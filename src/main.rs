mod data_structures;
mod helpers;

use crate::data_structures::Player;
extern crate reqwest;
extern crate tokio;
use clap::{App, Arg};
use reqwest::Error;
use serde_json::Value;

const DAY_IN_SEC: i32 = 86400;
const SLAYER_95_XP: i32 = 8771558;
const AVG_DAYS: i32 = 365;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // TODO ALEX: add flags for start up for different functionality
    // cargo run src/main.rs < input/usernames_test.csv

    // TODO ALEX: abstract this out into a separate function
    let matches = App::new("bingo-teams")
        .version("0.1.0")
        .author("Alexander <alexander.wesley.campbell@gmail.com>")
        .about("Helps create fair bingo teams for OSRS using Temple OSRS API.")
        // bingo-teams make-players input/usernames_test.csv
        .subcommand(
            App::new("make-players")
                .about("TODO: FILL THIS IN")
                .arg(Arg::with_name("file")
                    .help("The input csv listing purely usernames")
                    .required(true))
        )
        // 
        .subcommand(
            App::new("weight-players")
                .about("TODO: FILL THIS IN")
                .arg(Arg::with_name("file").
                    help("The input csv generated by 'make-players', after manually checking scores")
                    .required(true))
        )
        // 
        .subcommand(
            App::new("make-teams")
                .about("TODO: FILL THIS IN")
                .arg(Arg::with_name("file")
                    .help("The input csv generated by 'weight-players', after manually checking weights")
                    .required(true))
                .arg(Arg::with_name("team-count")
                .help("Indicates number of teams to place players in.")
                .required(true))
        )
        .get_matches();

    match matches.subcommand() {
        ("make-players", Some(sub_m)) => {
            println!("sub_m for make-players: {:?}", sub_m)
        }
        ("weight-players", Some(sub_m)) => {
            println!("sub_m for weight-players: {:?}", sub_m)
        }
        ("make-teams", Some(sub_m)) => {
            println!("sub_m for make-teams: {:?}", sub_m)
        }
        _ => unreachable!(),
    }

    // TODO ALEX: uncomment and abstract this all out
    // // Read in list of usernames from csv (stdin)
    // let players = helpers::read_usernames();

    // // TODO ALEX: Call temple to update players?

    // // Check temple osrs can be called
    // let mut players: Vec<Player> = create_players_with_temple(&players).await?;

    // // Print structs
    // for p in players.iter() {
    //     println!("{:?}", p)
    // }

    // helpers::weight_scores(&mut players);

    Ok(())
}

async fn create_players_with_temple(player_names: &Vec<String>) -> Result<Vec<Player>, Error> {
    let mut players = Vec::new();

    for name in player_names.iter() {
        // Get most current data
        let res_j: Value = reqwest::get(format!(
            "https://templeosrs.com/api/player_stats.php?player={}&bosses=1",
            name
        ))
        .await?
        .json()
        .await?;

        let res_avg_j: Value = reqwest::get(format!(
            "https://templeosrs.com/api/player_gains.php?player={}&time={}&bosses=1",
            name,
            DAY_IN_SEC * AVG_DAYS
        ))
        .await?
        .json()
        .await?;

        players.push(Player {
            name: name.clone(),
            slayer: res_j["data"]["Slayer"].as_u64().unwrap(),
            ehp: res_j["data"]["Ehp"].as_f64().unwrap(),
            ehb: res_j["data"]["Ehb"].as_f64().unwrap(),
            ehp_avg: res_avg_j["data"]["Ehp"].as_f64().unwrap(),
            ehb_avg: res_avg_j["data"]["Ehb"].as_f64().unwrap(),
            tiles_score: helpers::tile_score(res_j),
            ..Default::default()
        });
    }
    Ok(players)
}
